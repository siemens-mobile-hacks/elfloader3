import fs from 'node:fs';
import path from 'node:path';
import { sprintf } from 'sprintf-js';
import { globSync } from 'glob'
import * as ptr from './patterns.js';
import { findPattern, findPatternAll, ROOT_DIR, ucfirst } from "./utils.js";

type ELFPackConfig = {
	xcl: Record<string, string>;
	functions: Record<string, string>;
	SWILIB: Record<string, string>;
};

for (const file of globSync(`${ROOT_DIR}/ff/*.bin`)) {
	const model = path.basename(file).replace(/\.bin$/, '');
	genPatches(model);
}

function genPatches(model: string) {
	const config: ELFPackConfig = {
		xcl: {},
		functions: {},
		SWILIB: {},
	};

	swilibAddr(model, config);
	getUnusedExtRam(model, config);
	llInit(model, config);
	noIdleRestartOnSimError(model, config);
	socketsRaceConditionsBug(model, config);

	console.log(`[${model}]`);
	console.log(config);
	console.log();

	const xcl = [];
	const defs = [];
	const includes = [];

	for (const func in config.functions)
		defs.push(`\tdefadr\t${func},${config.functions[func]}`);

	if (config.xcl.PATCH_LL_INIT_HOOK && config.xcl.ELFLOADER_RAM) {
		xcl.push(`
			// 20k unused memory block
			-Z(DATA)DATA_Z,DATA_I,DATA_N=${config.xcl.ELFLOADER_RAM}

			// BL to any void-function in low level OS initialization (after ExtRAM init)
			-Z(CODE)PATCH_LL_INIT_HOOK=${config.xcl.PATCH_LL_INIT_HOOK}
		`);
	}

	if (config.xcl.PATCH_NO_IDLE_RESTART) {
		xcl.push(`
			// Fix IDLE CSM restart on SIM error
			-Z(CODE)PATCH_NO_IDLE_RESTART=${config.xcl.PATCH_NO_IDLE_RESTART}
		`);
		includes.push(`#include "patches/no_idle_restart.asm"`);
	}

	if (config.xcl.PATCH_SOCKET_FUNC_SOCKET) {
		xcl.push(`
			// Fix race condition in BSD sockets
			-Z(CODE)PATCH_SOCKET_FUNC_SOCKET=${config.xcl.PATCH_SOCKET_FUNC_SOCKET}
			-Z(CODE)PATCH_SOCKET_FUNC_BIND=${config.xcl.PATCH_SOCKET_FUNC_BIND}
			-Z(CODE)PATCH_SOCKET_FUNC_CONNECT=${config.xcl.PATCH_SOCKET_FUNC_CONNECT}
			-Z(CODE)PATCH_SOCKET_FUNC_SHUTDOWN=${config.xcl.PATCH_SOCKET_FUNC_SHUTDOWN}
			-Z(CODE)PATCH_SOCKET_FUNC_RECV=${config.xcl.PATCH_SOCKET_FUNC_RECV}
			-Z(CODE)PATCH_SOCKET_FUNC_RECV2=${config.xcl.PATCH_SOCKET_FUNC_RECV2}
			-Z(CODE)PATCH_SOCKET_FUNC_SENDTO=${config.xcl.PATCH_SOCKET_FUNC_SENDTO}
			-Z(CODE)PATCH_SOCKET_FUNC_LISTEN=${config.xcl.PATCH_SOCKET_FUNC_LISTEN}
			-Z(CODE)PATCH_SOCKET_FUNC_RECVFROM=${config.xcl.PATCH_SOCKET_FUNC_RECVFROM}
			-Z(CODE)PATCH_SOCKET_FUNC_RECVFROM2=${config.xcl.PATCH_SOCKET_FUNC_RECVFROM2}
			-Z(CODE)PATCH_SOCKET_FUNC_SEND=${config.xcl.PATCH_SOCKET_FUNC_SEND}
			-Z(CODE)PATCH_SOCKET_FUNC_SEND2=${config.xcl.PATCH_SOCKET_FUNC_SEND2}
			-Z(CODE)PATCH_SOCKET_FUNC_GETHOSTBYNAME=${config.xcl.PATCH_SOCKET_FUNC_GETHOSTBYNAME}
		`);
		includes.push(`#include "patches/race_condition_in_sockets.asm"`);
	}

	const swilib = [];
	for (const name in config.SWILIB)
		swilib.push(`-Z(CODE)${name}=${config.SWILIB[name]}`);
	xcl.push(`
		// SWILIB
		${swilib.join("\n")}
	`);

	if (!xcl.length && !defs.length)
		return;

	updateConfig(`${ROOT_DIR}/src/${model}.xcl`, `// Autogenerated with tools/src/porting.ts\n\n` + xcl.map((v) => {
		return v.split("\n").map((line) => line.trim()).join("\n").trim();
	}).join("\n\n"));
	updateConfig(`${ROOT_DIR}/src/rets_${model}.asm`, `; Autogenerated with tools/src/porting.ts\n\n` + [...defs, ...[""], ...includes].join("\n"));
}

function updateConfig(file: string, data: string) {
	const RE_REPLACE = /((?:;|\/\/)\s+<config>\n)(.*?)(\n(?:;|\/\/)\s+<\/config>)/sig;
	let text = fs.readFileSync(file).toString();
	text = text.replace(/\r\n/g, '\n');

	let m = RE_REPLACE.exec(text);
	if (!m)
		throw new Error(`${file} - <config> not found!`);

	text = text.replace(RE_REPLACE, m[1] + data + m[3])
	text = text.replace(/\n/g, '\r\n');
	fs.writeFileSync(file, text);
}

function swilibAddr(model: string, config: ELFPackConfig) {
	if (!ptr.SWILIB[model])
		throw new Error(`SWILIB addr not found for ${model}`);

	const functions: Record<string, [number, number]> = {
		"LIBR": [0, 0x1000],
		"SWILIB_FUNC00B": [0x00B, 1],
		"SWILIB_FUNC00C": [0x00C, 1],
		"SWILIB_FUNC095": [0x095, 1],
		"SWILIB_FUNC12B_12D": [0x12B, 3],
		"SWILIB_FUNC171": [0x171, 1],
		"SWILIB_FUNC172": [0x172, 1],
		"SWILIB_FUNC19C": [0x19C, 1],
		"SWILIB_FUNC1B8_1BB": [0x1B8, 4],
		"SWILIB_FUNC1E9": [0x1E9, 1],
		"SWILIB_FUNC2EE": [0x2EE, 18],
	};

	for (const name in functions) {
		const [from, size] = functions[name];
		config.SWILIB[name] = sprintf("%08X-%08X", ptr.SWILIB[model] + from * 4, ptr.SWILIB[model] + from * 4 + (size * 4) - 1);
	}
}

function noIdleRestartOnSimError(model: string, config: ELFPackConfig) {
	const foundNsg = findPattern(model, ptr.NO_RESTART_ON_SIM_ERROR_NSG);
	if (foundNsg) {
		config.xcl.PATCH_NO_IDLE_RESTART = sprintf("%08X-%08X", foundNsg.value, foundNsg.value + 0x18 - 1);
		config.functions.B_SkipSimErrorPopup = sprintf("0x%08X+1", (foundNsg.value + 0x18));
		return;
	}

	const foundElka = findPattern(model, ptr.NO_RESTART_ON_SIM_ERROR_ELKA) || findPattern(model, ptr.NO_RESTART_ON_SIM_ERROR_ELKA_V2);
	if (foundElka) {
		config.xcl.PATCH_NO_IDLE_RESTART = sprintf("%08X-%08X", foundElka.value, foundElka.value + 0x14 - 1);
		return;
	}
}

function llInit(model: string, config: ELFPackConfig) {
	const foundInjectPlace = findPattern(model, ptr.LL_INIT_NSG);
	const foundOldFunc = findPattern(model, ptr.LL_INIT_OLD_FUNC_NSG);

	if (!foundInjectPlace || !foundOldFunc)
		return;

	config.functions.OldFuncInOsInit = sprintf("0x%08X", foundOldFunc.value);
	config.xcl.PATCH_LL_INIT_HOOK = sprintf("%08X-%08X", foundInjectPlace.value, foundInjectPlace.value + 4 - 1);
}

function getUnusedExtRam(model: string, config: ELFPackConfig) {
	const found = findPattern(model, ptr.UNUSED_RAM_NSG);
	if (!found)
		return null;

	let freeMemPtr = found.value + 0xDD0;
	freeMemPtr &= ~0xFF;
	freeMemPtr += 0xC00;

	config.xcl.ELFLOADER_RAM = sprintf("%08X-%08X", freeMemPtr, freeMemPtr + 20 * 1024);

	return freeMemPtr;
}

function socketsRaceConditionsBug(model: string, config: ELFPackConfig) {
	const found = findPatternAll(model, ptr.SOCKETS_ERROR_EBSD_CHECK);
	const found2 = findPatternAll(model, ptr.SOCKETS_ERROR_EBSD_CHECK_V2);
	const nuSleepFound = findPattern(model, ptr.NU_SLEEP_FUNC_NSG);
	if (!found || !nuSleepFound)
		return;

	const functions = ["socket", "bind", "connect", "shutdown", "recv", "recv2", "sendto", "listen"];
	if (found.length != functions.length)
		return;

	const functions2 = ["recvfrom", "recvfrom2", "send", "send2", "gethostbyname"];
	if (found2.length != functions2.length)
		return;

	for (let i = 0; i < functions.length; i++) {
		const funcName = functions[i];
		config.xcl[`PATCH_SOCKET_FUNC_${funcName.toUpperCase()}`] = sprintf("%08X-%08X", found[i].value, found[i].value + 32 - 1);
		config.functions[`B_SocketFunc${ucfirst(funcName)}ReadStatus`] = sprintf("0x%08X+1", (found[i].value - 2));
		config.functions[`B_SocketFunc${ucfirst(funcName)}ExitLoop`] = sprintf("0x%08X+1", (found[i].value + 32));
	}

	for (let i = 0; i < functions2.length; i++) {
		const funcName = functions2[i];
		config.xcl[`PATCH_SOCKET_FUNC_${funcName.toUpperCase()}`] = sprintf("%08X-%08X", found2[i].value, found2[i].value + 32 - 1);
		config.functions[`B_SocketFunc${ucfirst(funcName)}ReadStatus`] = sprintf("0x%08X+1", (found2[i].value - 2));
		config.functions[`B_SocketFunc${ucfirst(funcName)}ExitLoop`] = sprintf("0x%08X+1", (found2[i].value + 32));
	}

	config.functions.NU_Sleep = sprintf("0x%08X", nuSleepFound.value);
}
