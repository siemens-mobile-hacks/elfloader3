import fs from 'node:fs';
import path from 'node:path';
import child_process from 'node:child_process';
import { sprintf } from 'sprintf-js';
import { globSync } from 'glob'
import * as ptr from './patterns.js';

const ROOT_DIR = path.resolve(`${import.meta.dirname}/../`);

for (let file of globSync(`${ROOT_DIR}/ff/*.bin`)) {
	let model = path.basename(file).replace(/\.bin$/, '');
	genPatches(model);
}

function genPatches(model) {
	let config = {
		PATCH_NO_IDLE_RESTART: null,
		PATCH_LL_INIT_HOOK: null,
		ELFLOADER_RAM: null,
		PATCH_SOCKET_FUNC_SOCKET: null,
		PATCH_SOCKET_FUNC_BIND: null,
		PATCH_SOCKET_FUNC_CONNECT: null,
		PATCH_SOCKET_FUNC_SHUTDOWN: null,
		PATCH_SOCKET_FUNC_RECV: null,
		PATCH_SOCKET_FUNC_RECV2: null,
		PATCH_SOCKET_FUNC_SENDTO: null,
		PATCH_SOCKET_FUNC_LISTEN: null,
		PATCH_SOCKET_FUNC_RECVFROM: null,
		PATCH_SOCKET_FUNC_RECVFROM2: null,
		PATCH_SOCKET_FUNC_SEND: null,
		PATCH_SOCKET_FUNC_SEND2: null,
		PATCH_SOCKET_FUNC_GETHOSTBYNAME: null,
		functions: {},
	};

	getUnsuedExtRam(model, config);
	llInit(model, config);
	noIdleRestartOnSimError(model, config);
	socketsRaceConditionsBug(model, config);

	console.log(`[${model}]`);
	console.log(config);
	console.log();

	let xcl = [];
	let defs = [];
	let includes = [];

	for (let func in config.functions)
		defs.push(`\tdefadr\t${func},${config.functions[func]}`);

	if (config.PATCH_LL_INIT_HOOK && config.ELFLOADER_RAM) {
		xcl.push(`
// 20k unused memory block
-Z(DATA)DATA_Z,DATA_I,DATA_N=${config.ELFLOADER_RAM}

// BL to any void-function in low level OS initialization (after ExtRAM init)
-Z(CODE)PATCH_LL_INIT_HOOK=${config.PATCH_LL_INIT_HOOK}
		`);
	}

	if (config.PATCH_NO_IDLE_RESTART) {
		xcl.push(`
// Fix IDLE CSM restart on SIM error
-Z(CODE)PATCH_NO_IDLE_RESTART=${config.PATCH_NO_IDLE_RESTART}
		`);
		includes.push(`#include "patches/no_idle_restart.asm"`);
	}

	if (config.PATCH_SOCKET_FUNC_SOCKET) {
		xcl.push(`
// Fix race condition in BSD sockets
-Z(CODE)PATCH_SOCKET_FUNC_SOCKET=${config.PATCH_SOCKET_FUNC_SOCKET}
-Z(CODE)PATCH_SOCKET_FUNC_BIND=${config.PATCH_SOCKET_FUNC_BIND}
-Z(CODE)PATCH_SOCKET_FUNC_CONNECT=${config.PATCH_SOCKET_FUNC_CONNECT}
-Z(CODE)PATCH_SOCKET_FUNC_SHUTDOWN=${config.PATCH_SOCKET_FUNC_SHUTDOWN}
-Z(CODE)PATCH_SOCKET_FUNC_RECV=${config.PATCH_SOCKET_FUNC_RECV}
-Z(CODE)PATCH_SOCKET_FUNC_RECV2=${config.PATCH_SOCKET_FUNC_RECV2}
-Z(CODE)PATCH_SOCKET_FUNC_SENDTO=${config.PATCH_SOCKET_FUNC_SENDTO}
-Z(CODE)PATCH_SOCKET_FUNC_LISTEN=${config.PATCH_SOCKET_FUNC_LISTEN}
-Z(CODE)PATCH_SOCKET_FUNC_RECVFROM=${config.PATCH_SOCKET_FUNC_RECVFROM}
-Z(CODE)PATCH_SOCKET_FUNC_RECVFROM2=${config.PATCH_SOCKET_FUNC_RECVFROM2}
-Z(CODE)PATCH_SOCKET_FUNC_SEND=${config.PATCH_SOCKET_FUNC_SEND}
-Z(CODE)PATCH_SOCKET_FUNC_SEND2=${config.PATCH_SOCKET_FUNC_SEND2}
-Z(CODE)PATCH_SOCKET_FUNC_GETHOSTBYNAME=${config.PATCH_SOCKET_FUNC_GETHOSTBYNAME}
`);
		includes.push(`#include "patches/race_condition_in_sockets.asm"`);
	}

	xcl = xcl.map((v) => v.trim());

	if (!xcl.length && !defs.length)
		return;

	updateConfig(`${ROOT_DIR}/src/${model}.xcl`, `// Autogenerated with tools/porting.js\n\n` + xcl.join("\n\n"));
	updateConfig(`${ROOT_DIR}/src/rets_${model}.asm`, `; Autogenerated with tools/porting.js\n\n` + [...defs, ...[""], ...includes].join("\n"));
}

function updateConfig(file, data) {
	const RE_REPLACE = /((?:;|\/\/)\s+<config>\n)(.*?)(\n(?:;|\/\/)\s+<\/config>)/sig;
	let text = fs.readFileSync(file).toString();
	text = text.replace(/\r\n/g, '\n');

	let m = RE_REPLACE.exec(text);
	if (!m) {
		console.warn(`${file} - <config> not found!`);
		return;
	}

	text = text.replace(RE_REPLACE, m[1] + data + m[3])
	text = text.replace(/\n/g, '\r\n');
	fs.writeFileSync(file, text);
}

function noIdleRestartOnSimError(model, config) {
	let foundNsg = findPattern(model, ptr.NO_RESTART_ON_SIM_ERROR_NSG);
	if (foundNsg) {
		config.PATCH_NO_IDLE_RESTART = sprintf("%08X-%08X", foundNsg.value, foundNsg.value + 0x18 - 1);
		config.functions.B_SkipSimErrorPopup = sprintf("0x%08X+1", (foundNsg.value + 0x18));
		return;
	}

	let foundElka = findPattern(model, ptr.NO_RESTART_ON_SIM_ERROR_ELKA) || findPattern(model, ptr.NO_RESTART_ON_SIM_ERROR_ELKA_V2);
	if (foundElka) {
		config.PATCH_NO_IDLE_RESTART = sprintf("%08X-%08X", foundElka.value, foundElka.value + 0x14 - 1);
		return;
	}

	if (foundElka) {
		config.PATCH_NO_IDLE_RESTART = sprintf("%08X-%08X", foundElka.value, foundElka.value + 0x14 - 1);
		return;
	}
}

function llInit(model, config) {
	let foundInjectPlace = findPattern(model, ptr.LL_INIT_NSG);
	let foundOldFunc = findPattern(model, ptr.LL_INIT_OLD_FUNC_NSG);

	if (!foundInjectPlace || !foundOldFunc)
		return;

	config.functions.OldFuncInOsInit = sprintf("0x%08X", foundOldFunc.value);
	config.PATCH_LL_INIT_HOOK = sprintf("%08X-%08X", foundInjectPlace.value, foundInjectPlace.value + 4 - 1);
}

function getUnsuedExtRam(model, config) {
	let found = findPattern(model, ptr.UNUSED_RAM_NSG);
	if (!found)
		return null;

	let freeMemPtr = found.value + 0xDD0;
	freeMemPtr &= ~0xFF;
	freeMemPtr += 0xC00;

	config.ELFLOADER_RAM = sprintf("%08X-%08X", freeMemPtr, freeMemPtr + 20 * 1024);

	return freeMemPtr;
}

function socketsRaceConditionsBug(model, config) {
	let found = findPatternAll(model, ptr.SOCKETS_ERROR_EBSD_CHECK);
	let found2 = findPatternAll(model, ptr.SOCKETS_ERROR_EBSD_CHECK_V2);
	let nuSleepFound = findPattern(model, ptr.NU_SLEEP_FUNC_NSG);
	if (!found || !nuSleepFound)
		return null;

	let functions = ["socket", "bind", "connect", "shutdown", "recv", "recv2", "sendto", "listen"];
	if (found.length != functions.length)
		return;

	let functions2 = ["recvfrom", "recvfrom2", "send", "send2", "gethostbyname"];
	if (found2.length != functions2.length)
		return;

	for (let i = 0; i < functions.length; i++) {
		let funcName = functions[i];
		config[`PATCH_SOCKET_FUNC_${funcName.toUpperCase()}`] = sprintf("%08X-%08X", found[i].value, found[i].value + 32 - 1);
		config.functions[`B_SocketFunc${ucfirst(funcName)}ReadStatus`] = sprintf("0x%08X+1", (found[i].value - 2));
		config.functions[`B_SocketFunc${ucfirst(funcName)}ExitLoop`] = sprintf("0x%08X+1", (found[i].value + 32));
	}

	for (let i = 0; i < functions2.length; i++) {
		let funcName = functions2[i];
		config[`PATCH_SOCKET_FUNC_${funcName.toUpperCase()}`] = sprintf("%08X-%08X", found2[i].value, found2[i].value + 32 - 1);
		config.functions[`B_SocketFunc${ucfirst(funcName)}ReadStatus`] = sprintf("0x%08X+1", (found2[i].value - 2));
		config.functions[`B_SocketFunc${ucfirst(funcName)}ExitLoop`] = sprintf("0x%08X+1", (found2[i].value + 32));
	}

	config.functions.NU_Sleep = sprintf("0x%08X", nuSleepFound.value);
}

function findPattern(model, pattern) {
	let { stdout } = child_process.spawnSync(`ptr89`, [
		'-f', `${ROOT_DIR}/ff/${model}.bin`,
		'-p', pattern,
		'-J',
	], {});
	return JSON.parse(stdout).patterns[0].results[0];
}

function findPatternAll(model, pattern) {
	let { stdout } = child_process.spawnSync(`ptr89`, [
		'-f', `${ROOT_DIR}/ff/${model}.bin`,
		'-p', pattern,
		'-J',
	], {});
	return JSON.parse(stdout).patterns[0].results;
}

function ucfirst(string) {
	return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
}
